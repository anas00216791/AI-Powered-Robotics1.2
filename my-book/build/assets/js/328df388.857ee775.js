"use strict";(self.webpackChunkmy_book=self.webpackChunkmy_book||[]).push([[429],{8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>a});var s=i(6540);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}},9456:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-gazebo-unity/chapter-01-gazebo","title":"Chapter 1: Gazebo Physics Simulation","description":"Introduction","source":"@site/docs/module-2-gazebo-unity/chapter-01-gazebo.md","sourceDirName":"module-2-gazebo-unity","slug":"/module-2-gazebo-unity/chapter-01-gazebo","permalink":"/module-2-gazebo-unity/chapter-01-gazebo","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: The Digital Twin (Gazebo & Unity)","permalink":"/module-2-gazebo-unity/"},"next":{"title":"Chapter 2: Unity for High-Fidelity Rendering","permalink":"/module-2-gazebo-unity/chapter-02-unity"}}');var o=i(4848),r=i(8453);const t={sidebar_position:1},a="Chapter 1: Gazebo Physics Simulation",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Understanding Physics Engines",id:"understanding-physics-engines",level:2},{value:"Core Physics Components",id:"core-physics-components",level:3},{value:"Physics Engines in Gazebo",id:"physics-engines-in-gazebo",level:3},{value:"Installing Gazebo with ROS 2",id:"installing-gazebo-with-ros-2",level:2},{value:"Creating Your First World",id:"creating-your-first-world",level:2},{value:"Example: Basic World File",id:"example-basic-world-file",level:3},{value:"Launching Your World",id:"launching-your-world",level:3},{value:"Physics Configuration Parameters",id:"physics-configuration-parameters",level:2},{value:"Time Step Configuration",id:"time-step-configuration",level:3},{value:"Gravity",id:"gravity",level:3},{value:"Contact Parameters",id:"contact-parameters",level:3},{value:"Building Complex Environments",id:"building-complex-environments",level:2},{value:"Adding Multiple Objects",id:"adding-multiple-objects",level:3},{value:"Using Model Database",id:"using-model-database",level:3},{value:"Integrating Robots with Gazebo",id:"integrating-robots-with-gazebo",level:2},{value:"Spawning a Robot from URDF",id:"spawning-a-robot-from-urdf",level:3},{value:"Adding Gazebo-Specific Tags to URDF",id:"adding-gazebo-specific-tags-to-urdf",level:3},{value:"Gazebo Plugins",id:"gazebo-plugins",level:2},{value:"Differential Drive Plugin",id:"differential-drive-plugin",level:3},{value:"Joint State Publisher Plugin",id:"joint-state-publisher-plugin",level:3},{value:"Testing Physics Behavior",id:"testing-physics-behavior",level:2},{value:"Experiment: Bouncing Ball",id:"experiment-bouncing-ball",level:3},{value:"Debugging Physics Issues",id:"debugging-physics-issues",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Simplify Collision Geometry",id:"simplify-collision-geometry",level:3},{value:"Adjust Update Rates",id:"adjust-update-rates",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-1-gazebo-physics-simulation",children:"Chapter 1: Gazebo Physics Simulation"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo is a powerful 3D robotics simulator that integrates seamlessly with ROS 2. It provides accurate physics simulation, sensor modeling, and a plugin architecture that allows you to test robot behaviors in realistic environments before deploying to hardware (Koenig & Howard, 2004)."}),"\n",(0,o.jsx)(n.p,{children:"In this chapter, you'll learn how physics engines work, how to create simulation worlds, and how to configure Gazebo for your robotics projects."}),"\n",(0,o.jsx)(n.h2,{id:"understanding-physics-engines",children:"Understanding Physics Engines"}),"\n",(0,o.jsx)(n.p,{children:"A physics engine simulates the laws of physics in a virtual environment. For robotics, this includes:"}),"\n",(0,o.jsx)(n.h3,{id:"core-physics-components",children:"Core Physics Components"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Rigid Body Dynamics"}),": How objects move and rotate under forces"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Collision Detection"}),": Determining when objects touch or overlap"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Contact Resolution"}),": Computing forces when objects collide"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Constraints"}),": Joints, springs, and other connections between bodies"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gravity"}),": The constant downward force affecting all objects"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"physics-engines-in-gazebo",children:"Physics Engines in Gazebo"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo supports multiple physics engines:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ODE (Open Dynamics Engine)"}),": Fast, stable, good for mobile robots"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Bullet"}),": Accurate collision detection, good for manipulation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"DART"}),": Excellent for legged locomotion and contact-rich scenarios"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Simbody"}),": High-fidelity biomechanical simulation"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The default is ODE, which provides a good balance of speed and accuracy for most applications."}),"\n",(0,o.jsx)(n.h2,{id:"installing-gazebo-with-ros-2",children:"Installing Gazebo with ROS 2"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo comes bundled with most ROS 2 installations. Verify your installation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Check Gazebo version\ngazebo --version\n\n# Launch Gazebo\ngazebo\n\n# Launch with ROS 2 integration\nros2 launch gazebo_ros gazebo.launch.py\n"})}),"\n",(0,o.jsx)(n.p,{children:"If Gazebo isn't installed:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Ubuntu/Debian\nsudo apt install ros-humble-gazebo-ros-pkgs\n\n# This includes Gazebo and ROS 2 integration packages\n"})}),"\n",(0,o.jsx)(n.h2,{id:"creating-your-first-world",children:"Creating Your First World"}),"\n",(0,o.jsx)(n.p,{children:"A Gazebo world is defined in an SDF (Simulation Description Format) file. Let's create a simple world."}),"\n",(0,o.jsx)(n.h3,{id:"example-basic-world-file",children:"Example: Basic World File"}),"\n",(0,o.jsxs)(n.p,{children:["Create a file named ",(0,o.jsx)(n.code,{children:"simple_world.sdf"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <world name="simple_world">\n\n    \x3c!-- Physics configuration --\x3e\n    <physics name="default_physics" default="true" type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n\n      \x3c!-- Gravity (m/s\xb2) --\x3e\n      <gravity>0 0 -9.81</gravity>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground Plane --\x3e\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n\n    \x3c!-- A simple box obstacle --\x3e\n    <model name="box_obstacle">\n      <pose>2 0 0.5 0 0 0</pose>\n      <static>false</static>\n\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n        </collision>\n\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>1 1 1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.1 0.1 1</ambient>\n            <diffuse>0.8 0.1 0.1 1</diffuse>\n          </material>\n        </visual>\n\n        <inertial>\n          <mass>10.0</mass>\n          <inertia>\n            <ixx>1.67</ixx>\n            <iyy>1.67</iyy>\n            <izz>1.67</izz>\n          </inertia>\n        </inertial>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"launching-your-world",children:"Launching Your World"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"gazebo simple_world.sdf\n"})}),"\n",(0,o.jsx)(n.p,{children:"You should see a ground plane with a red box floating above it. The box will fall due to gravity and land on the ground."}),"\n",(0,o.jsx)(n.h2,{id:"physics-configuration-parameters",children:"Physics Configuration Parameters"}),"\n",(0,o.jsx)(n.h3,{id:"time-step-configuration",children:"Time Step Configuration"}),"\n",(0,o.jsx)(n.p,{children:"The physics update rate determines simulation accuracy and speed:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<physics>\n  \x3c!-- Size of each physics step (seconds) --\x3e\n  <max_step_size>0.001</max_step_size>\n\n  \x3c!-- Target real-time speed (1.0 = real-time, 0.5 = half speed) --\x3e\n  <real_time_factor>1.0</real_time_factor>\n\n  \x3c!-- Physics updates per second --\x3e\n  <real_time_update_rate>1000</real_time_update_rate>\n</physics>\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Rule of thumb"}),": Smaller step sizes = more accurate but slower simulation."]}),"\n",(0,o.jsxs)(n.p,{children:["For mobile robots: ",(0,o.jsx)(n.code,{children:"0.001s"})," (1ms) is usually sufficient\nFor manipulation: ",(0,o.jsx)(n.code,{children:"0.0001s"})," (0.1ms) may be needed for stability"]}),"\n",(0,o.jsx)(n.h3,{id:"gravity",children:"Gravity"}),"\n",(0,o.jsx)(n.p,{children:"Change gravity for different scenarios:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Earth gravity --\x3e\n<gravity>0 0 -9.81</gravity>\n\n\x3c!-- Moon gravity (1/6 of Earth) --\x3e\n<gravity>0 0 -1.62</gravity>\n\n\x3c!-- Mars gravity --\x3e\n<gravity>0 0 -3.71</gravity>\n\n\x3c!-- Zero gravity (space) --\x3e\n<gravity>0 0 0</gravity>\n"})}),"\n",(0,o.jsx)(n.h3,{id:"contact-parameters",children:"Contact Parameters"}),"\n",(0,o.jsx)(n.p,{children:"Control how objects interact when colliding:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<collision name="collision">\n  <surface>\n    <friction>\n      <ode>\n        \x3c!-- Friction coefficients --\x3e\n        <mu>0.8</mu>   \x3c!-- Primary direction --\x3e\n        <mu2>0.8</mu2> \x3c!-- Secondary direction --\x3e\n      </ode>\n    </friction>\n\n    <contact>\n      <ode>\n        \x3c!-- Stiffness (N/m) - higher = less penetration --\x3e\n        <kp>1000000.0</kp>\n\n        \x3c!-- Damping (N\xb7s/m) - higher = less bouncing --\x3e\n        <kd>1.0</kd>\n\n        \x3c!-- Maximum contact correction velocity --\x3e\n        <max_vel>0.01</max_vel>\n\n        \x3c!-- Minimum penetration depth before correction --\x3e\n        <min_depth>0.001</min_depth>\n      </ode>\n    </contact>\n\n    <bounce>\n      \x3c!-- Coefficient of restitution (0 = no bounce, 1 = perfect bounce) --\x3e\n      <restitution_coefficient>0.0</restitution_coefficient>\n      <threshold>0.1</threshold>\n    </bounce>\n  </surface>\n</collision>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"building-complex-environments",children:"Building Complex Environments"}),"\n",(0,o.jsx)(n.h3,{id:"adding-multiple-objects",children:"Adding Multiple Objects"}),"\n",(0,o.jsx)(n.p,{children:"Create a more complex scene:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<world name="obstacle_course">\n  <include>\n    <uri>model://ground_plane</uri>\n  </include>\n\n  \x3c!-- Wall 1 --\x3e\n  <model name="wall_1">\n    <pose>5 0 1 0 0 0</pose>\n    <static>true</static>\n    <link name="link">\n      <collision name="collision">\n        <geometry>\n          <box><size>0.2 4 2</size></box>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <box><size>0.2 4 2</size></box>\n        </geometry>\n        <material>\n          <ambient>0.5 0.5 0.5 1</ambient>\n        </material>\n      </visual>\n    </link>\n  </model>\n\n  \x3c!-- Ramp --\x3e\n  <model name="ramp">\n    <pose>10 0 0.5 0 0.3 0</pose>\n    <static>true</static>\n    <link name="link">\n      <collision name="collision">\n        <geometry>\n          <box><size>4 2 0.1</size></box>\n        </geometry>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <box><size>4 2 0.1</size></box>\n        </geometry>\n        <material>\n          <ambient>0.3 0.6 0.3 1</ambient>\n        </material>\n      </visual>\n    </link>\n  </model>\n</world>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"using-model-database",children:"Using Model Database"}),"\n",(0,o.jsx)(n.p,{children:"Gazebo includes pre-built models:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Add a table --\x3e\n<include>\n  <uri>model://cafe_table</uri>\n  <pose>3 2 0 0 0 0</pose>\n</include>\n\n\x3c!-- Add a chair --\x3e\n<include>\n  <uri>model://chair</uri>\n  <pose>3 1 0 0 0 1.57</pose>\n</include>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Browse available models: ",(0,o.jsx)(n.a,{href:"http://models.gazebosim.org/",children:"http://models.gazebosim.org/"})]}),"\n",(0,o.jsx)(n.h2,{id:"integrating-robots-with-gazebo",children:"Integrating Robots with Gazebo"}),"\n",(0,o.jsx)(n.h3,{id:"spawning-a-robot-from-urdf",children:"Spawning a Robot from URDF"}),"\n",(0,o.jsx)(n.p,{children:"You can spawn your URDF robot (from Module 1) into Gazebo:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nimport os\n\ndef generate_launch_description():\n    # Read URDF file\n    urdf_file = 'simple_humanoid.urdf'\n    with open(urdf_file, 'r') as f:\n        robot_description = f.read()\n\n    # Spawn robot in Gazebo\n    spawn_entity = Node(\n        package='gazebo_ros',\n        executable='spawn_entity.py',\n        arguments=[\n            '-entity', 'my_robot',\n            '-topic', '/robot_description',\n            '-x', '0', '-y', '0', '-z', '1.0'\n        ],\n        output='screen'\n    )\n\n    # Robot state publisher\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{'robot_description': robot_description}]\n    )\n\n    return LaunchDescription([\n        robot_state_publisher,\n        spawn_entity\n    ])\n"})}),"\n",(0,o.jsx)(n.p,{children:"Launch with:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"ros2 launch spawn_robot.launch.py\n"})}),"\n",(0,o.jsx)(n.h3,{id:"adding-gazebo-specific-tags-to-urdf",children:"Adding Gazebo-Specific Tags to URDF"}),"\n",(0,o.jsx)(n.p,{children:"For physics simulation, add Gazebo tags to your URDF:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<robot name="my_robot">\n\n  <link name="base_link">\n    \x3c!-- Visual and collision as before --\x3e\n  </link>\n\n  \x3c!-- Gazebo-specific properties --\x3e\n  <gazebo reference="base_link">\n    \x3c!-- Material color in Gazebo --\x3e\n    <material>Gazebo/Blue</material>\n\n    \x3c!-- Physics properties --\x3e\n    <mu1>0.8</mu1>  \x3c!-- Friction coefficient 1 --\x3e\n    <mu2>0.8</mu2>  \x3c!-- Friction coefficient 2 --\x3e\n    <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n    <kd>1.0</kd>  \x3c!-- Contact damping --\x3e\n  </gazebo>\n\n</robot>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"gazebo-plugins",children:"Gazebo Plugins"}),"\n",(0,o.jsx)(n.p,{children:"Plugins extend Gazebo's functionality. Common plugins:"}),"\n",(0,o.jsx)(n.h3,{id:"differential-drive-plugin",children:"Differential Drive Plugin"}),"\n",(0,o.jsx)(n.p,{children:"For wheeled mobile robots:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<gazebo>\n  <plugin name="differential_drive" filename="libgazebo_ros_diff_drive.so">\n    \x3c!-- ROS 2 parameters --\x3e\n    <ros>\n      <namespace>/my_robot</namespace>\n      <remapping>cmd_vel:=cmd_vel</remapping>\n      <remapping>odom:=odom</remapping>\n    </ros>\n\n    \x3c!-- Wheel configuration --\x3e\n    <left_joint>left_wheel_joint</left_joint>\n    <right_joint>right_wheel_joint</right_joint>\n    <wheel_separation>0.5</wheel_separation>\n    <wheel_diameter>0.2</wheel_diameter>\n\n    \x3c!-- Limits --\x3e\n    <max_wheel_torque>20</max_wheel_torque>\n    <max_wheel_acceleration>1.0</max_wheel_acceleration>\n\n    \x3c!-- Output --\x3e\n    <publish_odom>true</publish_odom>\n    <publish_odom_tf>true</publish_odom_tf>\n    <odometry_frame>odom</odometry_frame>\n    <robot_base_frame>base_link</robot_base_frame>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"joint-state-publisher-plugin",children:"Joint State Publisher Plugin"}),"\n",(0,o.jsx)(n.p,{children:"Publishes joint positions to ROS 2:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<gazebo>\n  <plugin name="joint_states" filename="libgazebo_ros_joint_state_publisher.so">\n    <ros>\n      <remapping>joint_states:=joint_states</remapping>\n    </ros>\n    <update_rate>50</update_rate>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"testing-physics-behavior",children:"Testing Physics Behavior"}),"\n",(0,o.jsx)(n.h3,{id:"experiment-bouncing-ball",children:"Experiment: Bouncing Ball"}),"\n",(0,o.jsx)(n.p,{children:"Create a world to test coefficient of restitution:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<model name="bouncy_ball">\n  <pose>0 0 5 0 0 0</pose>\n  <link name="link">\n    <collision name="collision">\n      <geometry>\n        <sphere><radius>0.2</radius></sphere>\n      </geometry>\n      <surface>\n        <bounce>\n          <restitution_coefficient>0.9</restitution_coefficient>\n        </bounce>\n      </surface>\n    </collision>\n    <visual name="visual">\n      <geometry>\n        <sphere><radius>0.2</radius></sphere>\n      </geometry>\n      <material>\n        <ambient>1 0 0 1</ambient>\n      </material>\n    </visual>\n    <inertial>\n      <mass>1.0</mass>\n      <inertia>\n        <ixx>0.016</ixx>\n        <iyy>0.016</iyy>\n        <izz>0.016</izz>\n      </inertia>\n    </inertial>\n  </link>\n</model>\n'})}),"\n",(0,o.jsx)(n.p,{children:"The ball will bounce repeatedly, with height decreasing each time due to energy loss."}),"\n",(0,o.jsx)(n.h3,{id:"debugging-physics-issues",children:"Debugging Physics Issues"}),"\n",(0,o.jsx)(n.p,{children:"Common problems and solutions:"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Problem"}),": Objects fall through ground\n",(0,o.jsx)(n.strong,{children:"Solution"}),": Check collision geometry exists, verify ",(0,o.jsx)(n.code,{children:"<static>true</static>"})," for ground"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Problem"}),": Robot vibrates or explodes\n",(0,o.jsx)(n.strong,{children:"Solution"}),": Reduce time step size, check inertial properties, increase contact damping"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Problem"}),": Joints are unstable\n",(0,o.jsx)(n.strong,{children:"Solution"}),": Add damping to joints, check joint limits, reduce PID gains"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Problem"}),": Simulation runs too slow\n",(0,o.jsx)(n.strong,{children:"Solution"}),": Increase time step, disable shadows, reduce collision complexity"]}),"\n",(0,o.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(n.h3,{id:"simplify-collision-geometry",children:"Simplify Collision Geometry"}),"\n",(0,o.jsx)(n.p,{children:"Use simple shapes for collisions, complex meshes for visuals:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<link name="complex_object">\n  \x3c!-- Simple collision (fast) --\x3e\n  <collision name="collision">\n    <geometry>\n      <box><size>1 0.5 0.3</size></box>\n    </geometry>\n  </collision>\n\n  \x3c!-- Detailed visual (doesn\'t affect physics) --\x3e\n  <visual name="visual">\n    <geometry>\n      <mesh><uri>model://complex_mesh.dae</uri></mesh>\n    </geometry>\n  </visual>\n</link>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"adjust-update-rates",children:"Adjust Update Rates"}),"\n",(0,o.jsx)(n.p,{children:"Balance accuracy and speed:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:"<physics>\n  \x3c!-- For fast prototyping --\x3e\n  <max_step_size>0.005</max_step_size>\n  <real_time_update_rate>200</real_time_update_rate>\n\n  \x3c!-- For accurate simulation --\x3e\n  <max_step_size>0.0001</max_step_size>\n  <real_time_update_rate>10000</real_time_update_rate>\n</physics>\n"})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Start Simple"}),": Test with basic shapes before adding complexity"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Verify Inertial Properties"}),": Incorrect mass/inertia causes instability"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use Appropriate Time Steps"}),": Smaller for manipulation, larger for navigation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Static vs Dynamic"}),": Mark non-moving objects as ",(0,o.jsx)(n.code,{children:"<static>true</static>"})," for performance"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Test Incrementally"}),": Add one feature at a time and verify behavior"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Monitor Real-Time Factor"}),": If it drops below 0.5, simplify your world"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"In this chapter, you learned:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"How physics engines simulate forces, collisions, and dynamics"}),"\n",(0,o.jsx)(n.li,{children:"How to configure Gazebo's physics parameters"}),"\n",(0,o.jsx)(n.li,{children:"How to create worlds with objects and environments"}),"\n",(0,o.jsx)(n.li,{children:"How to integrate robots from URDF into Gazebo"}),"\n",(0,o.jsx)(n.li,{children:"How to use Gazebo plugins for robot control"}),"\n",(0,o.jsx)(n.li,{children:"How to debug and optimize physics simulations"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"With these skills, you can create realistic test environments for your robots. In the next chapter, you'll learn how Unity provides photorealistic rendering and human-robot interaction capabilities."}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Gazebo Tutorials: ",(0,o.jsx)(n.a,{href:"http://gazebosim.org/tutorials",children:"http://gazebosim.org/tutorials"})]}),"\n",(0,o.jsxs)(n.li,{children:["SDF Specification: ",(0,o.jsx)(n.a,{href:"http://sdformat.org/",children:"http://sdformat.org/"})]}),"\n",(0,o.jsxs)(n.li,{children:["Koenig, N., & Howard, A. (2004). Design and use paradigms for Gazebo, an open-source multi-robot simulator. ",(0,o.jsx)(n.em,{children:"IEEE/RSJ International Conference on Intelligent Robots and Systems"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Gazebo ROS 2 Integration: ",(0,o.jsx)(n.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs",children:"https://github.com/ros-simulation/gazebo_ros_pkgs"})]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Learning Check"}),":"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"\u2713 Understand how physics engines work"}),"\n",(0,o.jsx)(n.li,{children:"\u2713 Create SDF world files with custom environments"}),"\n",(0,o.jsx)(n.li,{children:"\u2713 Configure physics parameters for accurate simulation"}),"\n",(0,o.jsx)(n.li,{children:"\u2713 Spawn robots from URDF into Gazebo"}),"\n",(0,o.jsx)(n.li,{children:"\u2713 Use Gazebo plugins for robot control"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);