"use strict";(self.webpackChunkmy_book=self.webpackChunkmy_book||[]).push([[920],{2759:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"module-1-ros2/chapter-03-urdf","title":"Chapter 3: Humanoid URDF Modeling","description":"Introduction","source":"@site/docs/module-1-ros2/chapter-03-urdf.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/chapter-03-urdf","permalink":"/module-1-ros2/chapter-03-urdf","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2: Python Agents with rclpy","permalink":"/module-1-ros2/chapter-02-python"},"next":{"title":"Module 2: The Digital Twin (Gazebo & Unity)","permalink":"/module-2-gazebo-unity/"}}');var s=i(4848),t=i(8453);const o={sidebar_position:3},l="Chapter 3: Humanoid URDF Modeling",a={},d=[{value:"Introduction",id:"introduction",level:2},{value:"What is URDF?",id:"what-is-urdf",level:2},{value:"URDF vs. Other Formats",id:"urdf-vs-other-formats",level:3},{value:"Basic URDF Structure",id:"basic-urdf-structure",level:2},{value:"Step 1: Creating the Torso",id:"step-1-creating-the-torso",level:2},{value:"Understanding Coordinate Frames",id:"understanding-coordinate-frames",level:3},{value:"Step 2: Adding a Head",id:"step-2-adding-a-head",level:2},{value:"Understanding Joints",id:"understanding-joints",level:3},{value:"Step 3: Adding Arms",id:"step-3-adding-arms",level:2},{value:"Joint Types in URDF",id:"joint-types-in-urdf",level:2},{value:"1. Fixed Joint",id:"1-fixed-joint",level:3},{value:"2. Revolute Joint",id:"2-revolute-joint",level:3},{value:"3. Continuous Joint",id:"3-continuous-joint",level:3},{value:"4. Prismatic Joint",id:"4-prismatic-joint",level:3},{value:"5. Floating Joint",id:"5-floating-joint",level:3},{value:"6. Planar Joint",id:"6-planar-joint",level:3},{value:"Visualizing Your URDF in Rviz",id:"visualizing-your-urdf-in-rviz",level:2},{value:"Step 1: Check URDF Validity",id:"step-1-check-urdf-validity",level:3},{value:"Step 2: Create a Launch File",id:"step-2-create-a-launch-file",level:3},{value:"Step 3: Launch and Visualize",id:"step-3-launch-and-visualize",level:3},{value:"Step 4: Configure Rviz",id:"step-4-configure-rviz",level:3},{value:"Understanding the robot_state_publisher",id:"understanding-the-robot_state_publisher",level:2},{value:"Practical Tips for URDF Development",id:"practical-tips-for-urdf-development",level:2},{value:"1. Start Simple",id:"1-start-simple",level:3},{value:"2. Use Consistent Units",id:"2-use-consistent-units",level:3},{value:"3. Set Realistic Inertial Properties",id:"3-set-realistic-inertial-properties",level:3},{value:"4. Name Links and Joints Descriptively",id:"4-name-links-and-joints-descriptively",level:3},{value:"5. Test Frequently",id:"5-test-frequently",level:3},{value:"6. Comment Your URDF",id:"6-comment-your-urdf",level:3},{value:"Advanced: Xacro for Modular URDF",id:"advanced-xacro-for-modular-urdf",level:2},{value:"Summary",id:"summary",level:2},{value:"Further Reading",id:"further-reading",level:2},{value:"Congratulations!",id:"congratulations",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-3-humanoid-urdf-modeling",children:"Chapter 3: Humanoid URDF Modeling"})}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"So far, you've learned how to create ROS 2 nodes that communicate through topics and services. But how do you describe the physical structure of your robot to ROS 2? How does the system know where the sensors are located, how the joints move, or what the robot looks like?"}),"\n",(0,s.jsxs)(n.p,{children:["The answer is the ",(0,s.jsx)(n.strong,{children:"Unified Robot Description Format (URDF)"}),"\u2014an XML-based format for describing robot structures (ROS Wiki, 2024). URDF files define:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The physical structure (links and joints)"}),"\n",(0,s.jsx)(n.li,{children:"Visual appearance for simulation"}),"\n",(0,s.jsx)(n.li,{children:"Collision geometry for physics"}),"\n",(0,s.jsx)(n.li,{children:"Inertial properties for dynamics"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, you'll learn how to create a URDF model of a simple humanoid robot and visualize it using ROS 2 tools."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-urdf",children:"What is URDF?"}),"\n",(0,s.jsx)(n.p,{children:"URDF is the standard format for robot descriptions in the ROS ecosystem. Think of it as a blueprint that describes your robot's anatomy:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Links"}),": Rigid body parts (like bones) - torso, head, arms, legs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Joints"}),": Connections between links that define how they move relative to each other"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A URDF model forms a kinematic tree structure. Every robot has a ",(0,s.jsx)(n.strong,{children:"root link"})," (usually the base or torso), and all other links connect to it through joints, directly or indirectly."]}),"\n",(0,s.jsx)(n.h3,{id:"urdf-vs-other-formats",children:"URDF vs. Other Formats"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"URDF"}),": XML-based, human-readable, standard in ROS"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SDF"}),": Simulation Description Format, used by Gazebo, more features but more complex"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MJCF"}),": MuJoCo XML format, used by MuJoCo physics engine"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Xacro"}),": A macro language that generates URDF (we'll stick to pure URDF for simplicity)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"basic-urdf-structure",children:"Basic URDF Structure"}),"\n",(0,s.jsx)(n.p,{children:"A minimal URDF file has this structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="my_robot">\n  \x3c!-- Links define rigid body parts --\x3e\n  <link name="base_link">\n    \x3c!-- Visual: what it looks like --\x3e\n    \x3c!-- Collision: shape for physics --\x3e\n    \x3c!-- Inertial: mass and inertia properties --\x3e\n  </link>\n\n  \x3c!-- Joints connect links --\x3e\n  <joint name="joint_name" type="fixed">\n    <parent link="parent_link_name"/>\n    <child link="child_link_name"/>\n    \x3c!-- Transform from parent to child --\x3e\n  </joint>\n</robot>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Let's build a humanoid robot step by step."}),"\n",(0,s.jsx)(n.h2,{id:"step-1-creating-the-torso",children:"Step 1: Creating the Torso"}),"\n",(0,s.jsxs)(n.p,{children:["We'll start with the torso, which will be our root link. Create a file named ",(0,s.jsx)(n.code,{children:"simple_humanoid.urdf"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n\n  \x3c!-- Torso: the root link of our robot --\x3e\n  <link name="torso">\n    \x3c!-- Visual properties: what the torso looks like --\x3e\n    <visual>\n      <geometry>\n        \x3c!-- A box: width (x), depth (y), height (z) in meters --\x3e\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n      <material name="blue">\n        \x3c!-- RGBA color: red, green, blue, alpha (opacity) --\x3e\n        <color rgba="0.0 0.0 0.8 1.0"/>\n      </material>\n    </visual>\n\n    \x3c!-- Collision properties: simplified shape for physics --\x3e\n    <collision>\n      <geometry>\n        \x3c!-- Usually matches visual, but can be simpler for performance --\x3e\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </collision>\n\n    \x3c!-- Inertial properties: mass and inertia tensor --\x3e\n    <inertial>\n      <mass value="10.0"/>\n      \x3c!-- For a box, inertia depends on mass and dimensions --\x3e\n      \x3c!-- These are simplified values --\x3e\n      <inertia ixx="0.4" ixy="0.0" ixz="0.0"\n               iyy="0.4" iyz="0.0"\n               izz="0.1"/>\n    </inertial>\n  </link>\n\n</robot>\n'})}),"\n",(0,s.jsx)(n.p,{children:"This defines a simple torso as a blue box, 30cm wide, 20cm deep, and 50cm tall."}),"\n",(0,s.jsx)(n.h3,{id:"understanding-coordinate-frames",children:"Understanding Coordinate Frames"}),"\n",(0,s.jsxs)(n.p,{children:["In ROS 2 (and robotics generally), we use the ",(0,s.jsx)(n.strong,{children:"right-hand coordinate system"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"X-axis"})," (red): Forward"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Y-axis"})," (green): Left"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Z-axis"})," (blue): Up"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Each link has its own coordinate frame, positioned at the link's origin."}),"\n",(0,s.jsx)(n.h2,{id:"step-2-adding-a-head",children:"Step 2: Adding a Head"}),"\n",(0,s.jsx)(n.p,{children:"Now let's add a head connected to the top of the torso with a revolute (rotating) joint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n\n  \x3c!-- Torso --\x3e\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0.0 0.0 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.5"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <inertia ixx="0.4" ixy="0.0" ixz="0.0"\n               iyy="0.4" iyz="0.0"\n               izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <link name="head">\n    <visual>\n      <geometry>\n        \x3c!-- Sphere with radius in meters --\x3e\n        <sphere radius="0.12"/>\n      </geometry>\n      <material name="skin">\n        <color rgba="0.9 0.7 0.6 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.12"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      \x3c!-- For a sphere: I = (2/5) * m * r^2 --\x3e\n      <inertia ixx="0.0115" ixy="0.0" ixz="0.0"\n               iyy="0.0115" iyz="0.0"\n               izz="0.0115"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Neck joint: connects head to torso --\x3e\n  <joint name="neck_joint" type="revolute">\n    \x3c!-- Parent link: torso --\x3e\n    <parent link="torso"/>\n    \x3c!-- Child link: head --\x3e\n    <child link="head"/>\n\n    \x3c!-- Transform from parent\'s origin to child\'s origin --\x3e\n    \x3c!-- xyz: translation in meters (forward, left, up) --\x3e\n    \x3c!-- The head is 0.3m above the torso\'s center --\x3e\n    <origin xyz="0 0 0.3" rpy="0 0 0"/>\n\n    \x3c!-- Axis of rotation (Z-axis = yaw/pan) --\x3e\n    <axis xyz="0 0 1"/>\n\n    \x3c!-- Joint limits --\x3e\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="1.0"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"understanding-joints",children:"Understanding Joints"}),"\n",(0,s.jsxs)(n.p,{children:["We added a ",(0,s.jsx)(n.strong,{children:"revolute joint"})," (a hinge that can rotate). Key properties:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"type"})}),": Joint type (",(0,s.jsx)(n.code,{children:"revolute"}),", ",(0,s.jsx)(n.code,{children:"continuous"}),", ",(0,s.jsx)(n.code,{children:"prismatic"}),", ",(0,s.jsx)(n.code,{children:"fixed"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"origin"})}),": Position and orientation of the child relative to the parent","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"xyz"}),": translation in meters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rpy"}),": rotation in radians (roll, pitch, yaw)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"axis"})}),": Axis around which the joint rotates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"limit"})}),": Movement limits","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"lower"}),"/",(0,s.jsx)(n.code,{children:"upper"}),": Range of motion (radians for revolute)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"effort"}),": Maximum force/torque"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"velocity"}),": Maximum speed"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In our neck joint:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Head is positioned 0.3m above torso center"}),"\n",(0,s.jsx)(n.li,{children:"Rotates around Z-axis (yaw/looking left-right)"}),"\n",(0,s.jsx)(n.li,{children:"Limited to \xb190 degrees (\xb11.57 radians)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"step-3-adding-arms",children:"Step 3: Adding Arms"}),"\n",(0,s.jsx)(n.p,{children:"Let's add arms with multiple joints. Each arm will have:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A shoulder joint (revolute)"}),"\n",(0,s.jsx)(n.li,{children:"An upper arm link"}),"\n",(0,s.jsx)(n.li,{children:"An elbow joint (revolute)"}),"\n",(0,s.jsx)(n.li,{children:"A forearm link"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'  \x3c!-- Right Upper Arm --\x3e\n  <link name="right_upper_arm">\n    <visual>\n      <geometry>\n        \x3c!-- Cylinder: radius and length --\x3e\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      \x3c!-- Cylinders are along Z-axis by default, rotate 90\xb0 around Y to make horizontal --\x3e\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n      <material name="skin">\n        <color rgba="0.9 0.7 0.6 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.04" length="0.3"/>\n      </geometry>\n      <origin xyz="0 0 -0.15" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <origin xyz="0 0 -0.15"/>\n      <inertia ixx="0.012" ixy="0.0" ixz="0.0"\n               iyy="0.012" iyz="0.0"\n               izz="0.0012"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Shoulder Joint --\x3e\n  <joint name="right_shoulder" type="revolute">\n    <parent link="torso"/>\n    <child link="right_upper_arm"/>\n    \x3c!-- Position at right side of torso, near top --\x3e\n    <origin xyz="0 -0.15 0.2" rpy="0 0 0"/>\n    \x3c!-- Rotate around Y-axis (pitch) for up/down movement --\x3e\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="3.14" effort="20.0" velocity="1.0"/>\n  </joint>\n\n  \x3c!-- Right Forearm --\x3e\n  <link name="right_forearm">\n    <visual>\n      <geometry>\n        <cylinder radius="0.035" length="0.25"/>\n      </geometry>\n      <origin xyz="0 0 -0.125" rpy="0 0 0"/>\n      <material name="skin">\n        <color rgba="0.9 0.7 0.6 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.035" length="0.25"/>\n      </geometry>\n      <origin xyz="0 0 -0.125" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <origin xyz="0 0 -0.125"/>\n      <inertia ixx="0.0052" ixy="0.0" ixz="0.0"\n               iyy="0.0052" iyz="0.0"\n               izz="0.0006"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Right Elbow Joint --\x3e\n  <joint name="right_elbow" type="revolute">\n    <parent link="right_upper_arm"/>\n    <child link="right_forearm"/>\n    \x3c!-- Position at end of upper arm --\x3e\n    <origin xyz="0 0 -0.3" rpy="0 0 0"/>\n    \x3c!-- Rotate around Y-axis for elbow bend --\x3e\n    <axis xyz="0 1 0"/>\n    <limit lower="0.0" upper="2.36" effort="15.0" velocity="1.0"/>\n  </joint>\n'})}),"\n",(0,s.jsx)(n.p,{children:"For a complete robot, you would add the left arm, legs, and feet similarly. Here's the complete file with all limbs:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"pathname:///examples/simple_humanoid.urdf",children:"Download complete simple_humanoid.urdf"})}),"\n",(0,s.jsx)(n.h2,{id:"joint-types-in-urdf",children:"Joint Types in URDF"}),"\n",(0,s.jsx)(n.p,{children:"URDF supports several joint types:"}),"\n",(0,s.jsx)(n.h3,{id:"1-fixed-joint",children:"1. Fixed Joint"}),"\n",(0,s.jsx)(n.p,{children:"No movement\u2014rigidly attaches two links."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<joint name="fixed_joint" type="fixed">\n  <parent link="link1"/>\n  <child link="link2"/>\n  <origin xyz="0 0 0.5" rpy="0 0 0"/>\n</joint>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use for: sensors, structural connections"}),"\n",(0,s.jsx)(n.h3,{id:"2-revolute-joint",children:"2. Revolute Joint"}),"\n",(0,s.jsx)(n.p,{children:"Rotational motion with limits (like our neck and elbows)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<joint name="hinge" type="revolute">\n  <parent link="link1"/>\n  <child link="link2"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="10.0" velocity="1.0"/>\n</joint>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use for: elbows, knees, wheels with limits"}),"\n",(0,s.jsx)(n.h3,{id:"3-continuous-joint",children:"3. Continuous Joint"}),"\n",(0,s.jsx)(n.p,{children:"Rotational motion without limits (can spin 360\xb0+)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<joint name="wheel_joint" type="continuous">\n  <parent link="base"/>\n  <child link="wheel"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>\n  <limit effort="5.0" velocity="10.0"/>\n</joint>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use for: wheels, propellers"}),"\n",(0,s.jsx)(n.h3,{id:"4-prismatic-joint",children:"4. Prismatic Joint"}),"\n",(0,s.jsx)(n.p,{children:"Linear motion (sliding) with limits."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<joint name="slider" type="prismatic">\n  <parent link="base"/>\n  <child link="platform"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="0" upper="1.0" effort="100.0" velocity="0.5"/>\n</joint>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Use for: linear actuators, elevators"}),"\n",(0,s.jsx)(n.h3,{id:"5-floating-joint",children:"5. Floating Joint"}),"\n",(0,s.jsx)(n.p,{children:"6 degrees of freedom (rarely used in URDF)."}),"\n",(0,s.jsx)(n.h3,{id:"6-planar-joint",children:"6. Planar Joint"}),"\n",(0,s.jsx)(n.p,{children:"Motion in a plane (rarely used in URDF)."}),"\n",(0,s.jsx)(n.h2,{id:"visualizing-your-urdf-in-rviz",children:"Visualizing Your URDF in Rviz"}),"\n",(0,s.jsx)(n.p,{children:"Rviz is ROS 2's 3D visualization tool. Let's see our humanoid robot!"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-check-urdf-validity",children:"Step 1: Check URDF Validity"}),"\n",(0,s.jsx)(n.p,{children:"First, validate your URDF file:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"check_urdf simple_humanoid.urdf\n"})}),"\n",(0,s.jsx)(n.p,{children:"You should see output like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"robot name is: simple_humanoid\n---------- Successfully Parsed XML ---------------\nroot Link: torso has 4 child(ren)\n    child(1):  head\n    child(2):  right_upper_arm\n        child(1):  right_forearm\n    child(3):  left_upper_arm\n        child(1):  left_forearm\n"})}),"\n",(0,s.jsx)(n.p,{children:"If there are errors, the tool will tell you what's wrong."}),"\n",(0,s.jsx)(n.h3,{id:"step-2-create-a-launch-file",children:"Step 2: Create a Launch File"}),"\n",(0,s.jsxs)(n.p,{children:["Create a file named ",(0,s.jsx)(n.code,{children:"view_humanoid.launch.py"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n\n    # Path to your URDF file\n    urdf_file = 'simple_humanoid.urdf'\n\n    # Read the URDF file content\n    with open(urdf_file, 'r') as f:\n        robot_description = f.read()\n\n    # Robot State Publisher node\n    # This node publishes the robot's kinematic tree\n    robot_state_publisher_node = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        output='screen',\n        parameters=[{\n            'robot_description': robot_description,\n            'use_sim_time': False\n        }]\n    )\n\n    # Joint State Publisher GUI\n    # This provides sliders to move the robot's joints\n    joint_state_publisher_gui_node = Node(\n        package='joint_state_publisher_gui',\n        executable='joint_state_publisher_gui',\n        output='screen'\n    )\n\n    # Rviz node\n    # This opens the 3D visualization\n    rviz_node = Node(\n        package='rviz2',\n        executable='rviz2',\n        name='rviz2',\n        output='screen',\n        arguments=['-d', 'urdf_config.rviz'] if os.path.exists('urdf_config.rviz') else []\n    )\n\n    return LaunchDescription([\n        robot_state_publisher_node,\n        joint_state_publisher_gui_node,\n        rviz_node\n    ])\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-3-launch-and-visualize",children:"Step 3: Launch and Visualize"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"ros2 launch view_humanoid.launch.py\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will open:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rviz"}),": 3D visualization window"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Joint State Publisher GUI"}),": Sliders to control joints"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-4-configure-rviz",children:"Step 4: Configure Rviz"}),"\n",(0,s.jsx)(n.p,{children:"In Rviz:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Change ",(0,s.jsx)(n.strong,{children:"Fixed Frame"})," to ",(0,s.jsx)(n.code,{children:"torso"})," (in the left panel)"]}),"\n",(0,s.jsxs)(n.li,{children:["Click ",(0,s.jsx)(n.strong,{children:"Add"})," button (bottom left)"]}),"\n",(0,s.jsxs)(n.li,{children:["Select ",(0,s.jsx)(n.strong,{children:"RobotModel"})]}),"\n",(0,s.jsx)(n.li,{children:"You should now see your humanoid robot!"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Use the Joint State Publisher GUI sliders to move the robot's joints and see it in real-time."}),"\n",(0,s.jsx)(n.h2,{id:"understanding-the-robot_state_publisher",children:"Understanding the robot_state_publisher"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"robot_state_publisher"})," is a crucial ROS 2 node. It:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Reads your URDF file"}),"\n",(0,s.jsx)(n.li,{children:"Builds the kinematic tree"}),"\n",(0,s.jsxs)(n.li,{children:["Subscribes to ",(0,s.jsx)(n.code,{children:"/joint_states"})," topic (joint angles)"]}),"\n",(0,s.jsxs)(n.li,{children:["Publishes transforms (",(0,s.jsx)(n.code,{children:"/tf"}),") for every link"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'This allows other nodes to query: "Where is the right hand relative to the torso?" The answer is computed from the kinematic tree and current joint positions.'}),"\n",(0,s.jsx)(n.h2,{id:"practical-tips-for-urdf-development",children:"Practical Tips for URDF Development"}),"\n",(0,s.jsx)(n.h3,{id:"1-start-simple",children:"1. Start Simple"}),"\n",(0,s.jsx)(n.p,{children:"Build your robot incrementally. Start with one or two links, verify they work, then add more."}),"\n",(0,s.jsx)(n.h3,{id:"2-use-consistent-units",children:"2. Use Consistent Units"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lengths: meters"}),"\n",(0,s.jsx)(n.li,{children:"Angles: radians"}),"\n",(0,s.jsx)(n.li,{children:"Mass: kilograms"}),"\n",(0,s.jsx)(n.li,{children:"Time: seconds"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-set-realistic-inertial-properties",children:"3. Set Realistic Inertial Properties"}),"\n",(0,s.jsx)(n.p,{children:"Incorrect inertia can cause simulation instability. For simple shapes:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Box"})," (dimensions: x, y, z):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Ixx = (1/12) * m * (y\xb2 + z\xb2)\nIyy = (1/12) * m * (x\xb2 + z\xb2)\nIzz = (1/12) * m * (x\xb2 + y\xb2)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sphere"})," (radius: r):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"I = (2/5) * m * r\xb2\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cylinder"})," (radius: r, height: h, Z-axis aligned):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Ixx = Iyy = (1/12) * m * (3*r\xb2 + h\xb2)\nIzz = (1/2) * m * r\xb2\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-name-links-and-joints-descriptively",children:"4. Name Links and Joints Descriptively"}),"\n",(0,s.jsx)(n.p,{children:"Use clear, consistent naming:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"base_link"}),", ",(0,s.jsx)(n.code,{children:"torso"}),", ",(0,s.jsx)(n.code,{children:"head"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"left_shoulder"}),", ",(0,s.jsx)(n.code,{children:"right_elbow"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"front_left_wheel"}),", ",(0,s.jsx)(n.code,{children:"back_right_wheel"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-test-frequently",children:"5. Test Frequently"}),"\n",(0,s.jsxs)(n.p,{children:["After each addition, use ",(0,s.jsx)(n.code,{children:"check_urdf"})," and visualize in Rviz to catch errors early."]}),"\n",(0,s.jsx)(n.h3,{id:"6-comment-your-urdf",children:"6. Comment Your URDF"}),"\n",(0,s.jsx)(n.p,{children:"XML comments help you remember design decisions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Left arm: positioned at left side of torso --\x3e\n\x3c!-- Shoulder allows 180\xb0 range for reaching --\x3e\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-xacro-for-modular-urdf",children:"Advanced: Xacro for Modular URDF"}),"\n",(0,s.jsxs)(n.p,{children:["For complex robots, writing raw URDF becomes tedious. ",(0,s.jsx)(n.strong,{children:"Xacro"})," is a macro language that generates URDF:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid">\n\n  \x3c!-- Macro for creating an arm --\x3e\n  <xacro:macro name="arm" params="prefix reflect">\n    <link name="${prefix}_upper_arm">\n      \x3c!-- Link definition --\x3e\n    </link>\n\n    <joint name="${prefix}_shoulder" type="revolute">\n      <parent link="torso"/>\n      <child link="${prefix}_upper_arm"/>\n      <origin xyz="0 ${reflect*0.15} 0.2"/>\n      \x3c!-- Rest of joint definition --\x3e\n    </joint>\n  </xacro:macro>\n\n  \x3c!-- Instantiate arms --\x3e\n  <xacro:arm prefix="right" reflect="-1"/>\n  <xacro:arm prefix="left" reflect="1"/>\n\n</robot>\n'})}),"\n",(0,s.jsx)(n.p,{children:"Xacro reduces repetition and makes your robot description maintainable. Convert to URDF with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"xacro my_robot.xacro > my_robot.urdf\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, you learned:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"URDF"})," is the standard format for describing robot structures in ROS 2"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Links"})," represent rigid body parts with visual, collision, and inertial properties"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Joints"})," connect links and define how they move relative to each other"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Joint types"})," include fixed, revolute, continuous, and prismatic"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"robot_state_publisher"})," publishes the robot's kinematic tree to the ROS 2 ecosystem"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Rviz"})," allows 3D visualization of your URDF models"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"check_urdf"})," validates your URDF syntax and structure"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can now describe robot structures in code and visualize them in ROS 2 tools\u2014a critical skill for robotics development. In future modules, you'll learn how to use these models in physics simulators like Gazebo and how to integrate perception and AI for intelligent robot behaviors."}),"\n",(0,s.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["URDF Specification: ",(0,s.jsx)(n.a,{href:"http://wiki.ros.org/urdf/XML",children:"http://wiki.ros.org/urdf/XML"})]}),"\n",(0,s.jsxs)(n.li,{children:["URDF Tutorials: ",(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Main.html",children:"https://docs.ros.org/en/humble/Tutorials/Intermediate/URDF/URDF-Main.html"})]}),"\n",(0,s.jsxs)(n.li,{children:["Xacro Documentation: ",(0,s.jsx)(n.a,{href:"http://wiki.ros.org/xacro",children:"http://wiki.ros.org/xacro"})]}),"\n",(0,s.jsxs)(n.li,{children:["Rviz User Guide: ",(0,s.jsx)(n.a,{href:"https://github.com/ros2/rviz",children:"https://github.com/ros2/rviz"})]}),"\n",(0,s.jsxs)(n.li,{children:["robot_state_publisher: ",(0,s.jsx)(n.a,{href:"https://github.com/ros/robot_state_publisher",children:"https://github.com/ros/robot_state_publisher"})]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Learning Check"}),": Before finishing this module, make sure you can:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"\u2713 Create a valid URDF file with multiple links and joints"}),"\n",(0,s.jsx)(n.li,{children:"\u2713 Explain the difference between revolute, continuous, and fixed joints"}),"\n",(0,s.jsx)(n.li,{children:"\u2713 Validate a URDF file using check_urdf"}),"\n",(0,s.jsx)(n.li,{children:"\u2713 Visualize a robot model in Rviz"}),"\n",(0,s.jsx)(n.li,{children:"\u2713 Understand the role of robot_state_publisher"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"congratulations",children:"Congratulations!"}),"\n",(0,s.jsx)(n.p,{children:"You've completed Module 1: The Robotic Nervous System (ROS 2). You now understand:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"How ROS 2 provides communication infrastructure for robots"}),"\n",(0,s.jsx)(n.li,{children:"How to create Python nodes that publish, subscribe, and use services"}),"\n",(0,s.jsx)(n.li,{children:"How to model robot structures using URDF"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These skills form the foundation for all ROS 2 development. In the next modules, you'll learn how to use simulation environments, advanced perception, and AI models to build truly intelligent robotic systems."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Continue to Module 2: Gazebo & Unity Simulation (coming soon)"})," \u2192"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var r=i(6540);const s={},t=r.createContext(s);function o(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);